# -*- coding: utf-8 -*-
"""streamlit-app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/197CkMrwMiEbRO0YGglnfWZGwEkiNNHZG
"""

import streamlit as st
import pandas as pd
import numpy as np
import os
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document

st.set_page_config(page_title="📚 AI-Powered Book Discovery", layout="wide")
st.title("📚 AI-Powered Book Discovery Platform")
st.write("Find books based on semantic meaning and emotional tone.")

def load_books():
    books = pd.read_csv("books_with_emotions.csv")
    books["large_thumbnail"] = books["thumbnail"].fillna("") + "&fife=w800"
    books["large_thumbnail"] = np.where(
        books["large_thumbnail"].isna(),
        "cover-not-found.jpg",
        books["large_thumbnail"]
    )
    return books

books = load_books()

@st.cache_resource
def load_faiss():
    embedding_model = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
    if os.path.exists("faiss_index/index.faiss") and os.path.exists("faiss_index/index.pkl"):
        return FAISS.load_local("faiss_index", embedding_model, allow_dangerous_deserialization=True)

    tagged_lines = books["isbn13"].astype(str) + " " + books["description"].fillna("")
    documents = [Document(page_content=line.strip()) for line in tagged_lines if line.strip()]

    db = FAISS.from_documents(documents, embedding_model)
    db.save_local("faiss_index")
    return db
db_books = load_faiss()

def retrieve_semantic_recommendations(query=None, category=None, tone=None, initial_top_k=50, final_top_k=16):
    if query:
        recs = db_books.similarity_search(query, k=initial_top_k)
        books_list = [int(rec.page_content.strip('"').split()[0]) for rec in recs]
        book_recs = books[books["isbn13"].isin(books_list)].copy()
    else:
        book_recs = books.copy()

    if category and category != "All":
        book_recs = book_recs[book_recs["simple_categories"] == category]

    if tone and tone != "All":
        tone_column = {
            "Happy": "joy",
            "Surprising": "surprise",
            "Angry": "anger",
            "Suspenseful": "fear",
            "Sad": "sadness"
        }.get(tone)
        if tone_column:
            book_recs = book_recs.sort_values(by=tone_column, ascending=False)

    return book_recs.head(final_top_k)

# ---------------- UI ----------------
query = st.text_input("Enter a book description (optional):")
categories = ["All"] + sorted(books["simple_categories"].dropna().unique())
tones = ["All", "Happy", "Surprising", "Angry", "Suspenseful", "Sad"]

col1, col2 = st.columns(2)
with col1:
    category = st.selectbox("Filter by category:", categories)
with col2:
    tone = st.selectbox("Filter by emotional tone:", tones)

if st.button("🔍 Find Recommendations"):
    if not query and category == "All" and tone == "All":
        st.warning("Please enter a description or select at least one filter.")
    else:
        with st.spinner("🔎 Searching for books..."):
            recommendations = retrieve_semantic_recommendations(query, category, tone)

        if recommendations.empty:
            st.warning("No recommendations found.")
        else:
            for _, row in recommendations.iterrows():
                col1, col2 = st.columns([1, 4])
                with col1:
                    st.image(row["large_thumbnail"], use_container_width=True)
                with col2:
                    authors_split = row["authors"].split(";")
                    if len(authors_split) == 2:
                        authors_str = f"{authors_split[0]} and {authors_split[1]}"
                    elif len(authors_split) > 2:
                        authors_str = f"{', '.join(authors_split[:-1])}, and {authors_split[-1]}"
                    else:
                        authors_str = row["authors"]

                    st.markdown(f"### {row['title']}")
                    st.markdown(f"**Author(s):** {authors_str}")
                    st.markdown(f"**Rating:** {row['average_rating']}")
                    st.markdown(row["description"])